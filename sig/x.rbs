module X
  VERSION: Gem::Version

  class BearerTokenAuthenticator
    attr_accessor bearer_token: String
    def initialize: (String bearer_token) -> void
    def header: (Net::HTTPRequest _request) -> Hash[String, String]
  end

  class OAuthAuthenticator
    OAUTH_VERSION: String
    OAUTH_SIGNATURE_METHOD: String
    OAUTH_SIGNATURE_ALGORITHM: String

    attr_accessor api_key: String
    attr_accessor api_key_secret: String
    attr_accessor access_token: String
    attr_accessor access_token_secret: String
    def initialize: (String api_key, String api_key_secret, String access_token, String access_token_secret) -> void
    def header: (Net::HTTPRequest request) -> Hash[String, String]

    private
    def parse_request: (Net::HTTPRequest request) -> [String, String, Hash[String, String]]
    def parse_query_params: (String query_string) -> Hash[String, String]
    def uri_without_query: (URI::Generic uri) -> String
    def build_oauth_header: (String method, String url, Hash[String, String] query_params) -> String
    def default_oauth_params: -> Hash[String, String]
    def generate_signature: (String method, String url, Hash[String, String] params) -> String
    def hmac_signature: (String base_string) -> String
    def signature_base_string: (String method, String url, Hash[String, String] params) -> String
    def signing_key: -> String
    def format_oauth_header: (Hash[String, String] params) -> String
    def escape: (String value) -> String
  end

  class ClientError < Error
  end

  class BadGateway < ClientError
  end

  class BadRequest < ClientError
  end

  class ConnectionException < ClientError
  end

  class Error < StandardError
    def initialize: (String msg, ?Net::HTTPResponse? response) -> void
  end

  class Forbidden < ClientError
  end

  class GatewayTimeout < ClientError
  end

  class Gone < ClientError
  end

  class InternalServerError < ServerError
  end

  class NetworkError < Error
  end

  class NotAcceptable < ClientError
  end

  class NotFound < ClientError
  end

  class PayloadTooLarge < ClientError
  end

  class ServerError < Error
  end

  class ServiceUnavailable < ServerError
  end

  class TooManyRedirects < ClientError
  end

  class TooManyRequests < ClientError
    @response: Net::HTTPResponse

    def initialize: (String msg, Net::HTTPResponse? response) -> void
    def limit: -> Integer
    def remaining: -> Integer
    def reset_at: -> Time
    def reset_in: -> Integer?
  end

  class Unauthorized < ClientError
  end

  class UnprocessableEntity < ClientError
  end

  class Connection
    DEFAULT_HOST: String
    DEFAULT_PORT: Integer
    DEFAULT_OPEN_TIMEOUT: Integer
    DEFAULT_READ_TIMEOUT: Integer
    DEFAULT_WRITE_TIMEOUT: Integer
    DEFAULT_DEBUG_OUTPUT: IO
    NETWORK_ERRORS: Array[(singleton(Errno::ECONNREFUSED) | singleton(Errno::ECONNRESET) | singleton(Net::OpenTimeout) | singleton(Net::ReadTimeout) | singleton(OpenSSL::SSL::SSLError))]

    extend Forwardable

    attr_accessor open_timeout : Float | Integer
    attr_accessor read_timeout : Float | Integer
    attr_accessor write_timeout : Float | Integer
    attr_accessor debug_output : IO

    attr_reader proxy_uri: URI::Generic?
    attr_reader proxy_host : String?
    attr_reader proxy_port : Integer?
    attr_reader proxy_user : String?
    attr_reader proxy_pass : String?

    def initialize: (?open_timeout: Float | Integer, ?read_timeout: Float | Integer, ?write_timeout: Float | Integer, ?proxy_url: URI::Generic? | String?, ?debug_output: IO) -> void
    def proxy_url=: (URI::Generic | String proxy_url) -> void
    def send_request: (Net::HTTPRequest request) -> Net::HTTPResponse

    private
    def build_http_client: (?String host, ?Integer port) -> Net::HTTP
    def configure_http_client: (Net::HTTP http_client) -> Net::HTTP
  end

  class RequestBuilder
    HTTP_METHODS: Hash[Symbol, (singleton(Net::HTTP::Get) | singleton(Net::HTTP::Post) | singleton(Net::HTTP::Put) | singleton(Net::HTTP::Delete))]
    DEFAULT_HEADERS: Hash[String, String]

    def initialize: (?content_type: String, ?user_agent: String) -> void
    def build: (BearerTokenAuthenticator | OAuthAuthenticator authenticator, Symbol http_method, URI::Generic uri, ?body: String?, ?headers: Hash[String, String]) -> (Net::HTTPRequest)

    private
    def create_request: (Symbol http_method, URI::Generic uri, String? body) -> (Net::HTTPRequest)
    def add_authentication: (Net::HTTPRequest request, BearerTokenAuthenticator | OAuthAuthenticator authenticator) -> void
    def add_headers: (Net::HTTPRequest request, Hash[String, String] headers) -> void
    def escape_query_params: (URI::Generic uri) -> URI::Generic
  end

  class RedirectHandler
    DEFAULT_MAX_REDIRECTS: Integer

    attr_reader authenticator: BearerTokenAuthenticator | OAuthAuthenticator
    attr_reader connection: Connection
    attr_reader request_builder: RequestBuilder
    attr_reader max_redirects: Integer
    def initialize: (BearerTokenAuthenticator | OAuthAuthenticator authenticator, Connection connection, RequestBuilder request_builder, ?max_redirects: Integer) -> void
    def handle_redirects: (Net::HTTPResponse response, Net::HTTPRequest original_request, String original_base_url, ?Integer redirect_count) -> Net::HTTPResponse

    private
    def build_new_uri: (Net::HTTPResponse response, String original_base_url) -> URI::Generic
    def build_request: (Net::HTTPRequest original_request, URI::Generic new_uri) -> Net::HTTPRequest
    def send_new_request: (URI::Generic new_uri, Net::HTTPRequest new_request) -> Net::HTTPResponse
  end

  class ResponseHandler
    DEFAULT_ARRAY_CLASS: Class
    DEFAULT_OBJECT_CLASS: Class
    ERROR_CLASSES: Hash[Integer, singleton(Unauthorized) | singleton(BadRequest) | singleton(Forbidden) | singleton(InternalServerError) | singleton(NotFound) | singleton(PayloadTooLarge) | singleton(ServiceUnavailable) | singleton(TooManyRequests)]
    JSON_CONTENT_TYPE_REGEXP: Regexp

    attr_accessor array_class: Class
    attr_accessor object_class: Class
    def initialize: (?array_class: Class, ?object_class: Class) -> void
    def handle: (Net::HTTPResponse response) -> untyped

    private
    def success?: (Net::HTTPResponse response) -> bool
    def error: (Net::HTTPResponse response) -> (Unauthorized | BadRequest | Forbidden | InternalServerError | NotFound | PayloadTooLarge | ServiceUnavailable | TooManyRequests)
    def error_class: (Net::HTTPResponse response) -> (singleton(Unauthorized) | singleton(BadRequest) | singleton(Forbidden) | singleton(InternalServerError) | singleton(NotFound) | singleton(PayloadTooLarge) | singleton(ServiceUnavailable) | singleton(TooManyRequests))
    def error_message: (Net::HTTPResponse response) -> String
    def message_from_json_response:  (Net::HTTPResponse response) -> String
    def json?: (Net::HTTPResponse response) -> bool
  end

  class Client
    DEFAULT_BASE_URL: String

    extend Forwardable
    @authenticator: BearerTokenAuthenticator | OAuthAuthenticator
    @connection: Connection
    @request_builder: RequestBuilder
    @redirect_handler: RedirectHandler
    @response_handler: ResponseHandler

    attr_accessor access_token: String
    attr_accessor access_token_secret: String
    attr_accessor api_key: String
    attr_accessor api_key_secret: String
    attr_accessor bearer_token: String
    attr_accessor base_url: String
    attr_accessor open_timeout: Float | Integer
    attr_accessor read_timeout: Float | Integer
    attr_accessor write_timeout: Float | Integer
    attr_accessor proxy_url: String
    attr_accessor debug_output: IO
    attr_accessor array_class: Class
    attr_accessor object_class: Class
    attr_accessor max_redirects: Integer
    attr_accessor authenticator: BearerTokenAuthenticator | OAuthAuthenticator
    attr_accessor connection: Connection
    attr_accessor request_builder: RequestBuilder
    attr_accessor redirect_handler: RedirectHandler
    attr_accessor response_handler: ResponseHandler

    def initialize: (?bearer_token: String?, ?api_key: String?, ?api_key_secret: String?, ?access_token: String?, ?access_token_secret: String?, ?base_url: String, ?open_timeout: Float | Integer, ?read_timeout: Float | Integer, ?write_timeout: Float | Integer, ?proxy_url: URI::Generic? | String?, ?debug_output: IO, ?array_class: Class, ?object_class: Class, ?max_redirects: Integer) -> void
    def get: (String endpoint, ?headers: Hash[String, String]) -> untyped
    def post: (String endpoint, ?String? body, ?headers: Hash[String, String]) -> untyped
    def put: (String endpoint, ?String? body, ?headers: Hash[String, String]) -> untyped
    def delete: (String endpoint, ?headers: Hash[String, String]) -> untyped

    private
    def initialize_authenticator: (String? bearer_token, String? api_key, String? api_key_secret, String? access_token, String? access_token_secret) -> (BearerTokenAuthenticator | OAuthAuthenticator)
    def send_request: (Symbol http_method, String endpoint, headers: Hash[String, String], ?body: String?) -> untyped
  end

  module MediaUpload
    MAX_RETRIES: Integer
    BYTES_PER_MB: Integer
    MEDIA_CATEGORIES: Array[String]
    DM_GIF: String
    DM_IMAGE: String
    DM_VIDEO: String
    SUBTITLES: String
    TWEET_GIF: String
    TWEET_IMAGE: String
    TWEET_VIDEO: String
    DEFAULT_MIME_TYPE: String
    MIME_TYPES: Array[String]
    GIF_MIME_TYPE: String
    JPEG_MIME_TYPE: String
    MP4_MIME_TYPE: String
    PNG_MIME_TYPE: String
    SUBRIP_MIME_TYPE: String
    WEBP_MIME_TYPE: String
    MIME_TYPE_MAP: Hash[String, String]
    extend MediaUpload

    def media_upload: (client: Client, file_path: String, media_category: String, ?media_type: String, ?boundary: String) -> untyped
    def chunked_media_upload: (client: Client, file_path: String, media_category: String, ?media_type: String, ?boundary: String, ?chunk_size_mb: Integer) -> untyped
    def await_processing: (client: Client, media: untyped) -> untyped

    private
    def validate!: (file_path: String, media_category: String) -> nil
    def infer_media_type: (String file_path, String media_category) -> String
    def init: (Client upload_client, String file_path, String media_type, String media_category) -> untyped
    def split: (String file_path, Integer chunk_size) -> Array[String]
    def append: (Client upload_client, Array[String] chunk_paths, untyped media, String media_type, ?String boundary) -> Array[String]
    def upload_chunk: (Client upload_client, String query, String chunk_path, String media_type, ?Hash[String, String] headers) -> Integer?
    def cleanup_chunk: (String chunk_path) -> Integer?
    def finalize: (Client upload_client, untyped media) -> untyped
    def construct_upload_body: (String file_path, String media_type, ?String boundary) -> String
  end

  class CGI
    def self.escape: (String value) -> String
    def self.escape_params: (Hash[String, String] | Array[[String, String]] params) -> String
  end
end

class Dir
  def self.mktmpdir: (?String? prefix_suffix) -> String
end
